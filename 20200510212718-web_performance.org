#+TITLE: Web Performance

* Resources
- [[https://github.com/thedaviddias/Front-End-Performance-Checklist][Front-End Performance Checklist]]

* Thinking about performance
A content-centric website needs to think differently about perforance compared to an application you
spend a lot of time in (ex: Fastmail).

1. Javascript parsing/compilation
2. Rendering the webpage
3. Network load

Two general rules when thinking about performance:
1. Doing less stuff takes less time
2. If you can do it later, do it later
3. If someone else can do it, let them do it

* Benchmarking
Figure out where the biggest amount of hurt is. React in development is already taking advantage of
the API, but you can use it yourself as well.

#+BEGIN_SRC javascript
let iterations = 1e7

const a = 1
const b = 2

const add = (x, y) => x + y

performance.mark('start')
while (iterations--) {
  add(a, b)
}
performance.mark('end')
performance.measure('My own user timing', 'start', 'end')
#+END_SRC

* Issues with Layout and Reflow
are very expensive in terms of performance, since they could be equivalent as to creating a whole
new page.

- block operation (everything else stops, even Javascript)
- consumes a lot of CPU
- very noticeable if it happens often

A reflow of an element causes the reflow of it's parents and children. That means in 90% of the time
reflowing 1 element, causes a reflow of all elements.

The fact reflowing is so expensive is that usually it's followed by a repaint, which is also an
expensive operation.

Avoiding reflows by:
- changing classes in the lowest level of the DOM tree
- avoid modifying/using inline styles
- trade smoothness for speed when animating in Javascript
- batch DOM manipulations (React, Angular, Vue, etc do it for you)

*Layout thrashing* (Forced synchronous layout) occurs when Javascript writes, then reads, from the
DOM, multiple times causing the document to reflow. One way to discover is to anayze the performance
and seeing a lot of purple, which indicates recalcuating style and layout.

The act of reading a style/layout forces the browser to find the most up-to-date answer, causing it
to write, before it's able to give you an answer. Notice that it effectively stops the Javascript
execution.

Always seperate read from writing to prevent the layout thrashing. The easiest way to accomplish the
separation is to perform the writing later, using ~requestAnimationFrame~. Or use an external library
like ~fastdom~.

The main solution is to not keep your state in the DOM, which is what most modern frontend
frameworks are doing (React, Angular, Vue, etc). If you keep the state in the component, you only
need to write to DOM thus eliminating chances of doing accidental layout thrashing.
