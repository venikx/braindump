#+TITLE: The C Programming Language
#+AUTHOR: AnaRobynn
#+FILETAGS: :c:
#+STARTUP: hideblocks

Related: [[file:algorithms.org][wiki:Algorithms]], [[file:cryptography.org][wiki:Cryptography]]

* Entry point ~main()~
  is a mandatory function in C programs as it defines the entry point of the program.

  #+BEGIN_SRC C
     // program runs without responding to command line arguments
     int main(void){}

     // argc :: arguments count, argv[] :: argument vector Trying to access arguments outside
     // the memory boundary (argc) results in a 'segmentation fault'
     int main(int argc, string argv[]){}
  #+END_SRC

* Compiling
  1. *Pre-processing*: Copy-paste the included code from libraries.
  2. *Compiling*: Transforms source code to assembly code.
  3. *Assembling*: Assembles the code into machine code.
  4. *Linking*: Links the different assembled code from you and the included libraries into
     a program.

* Debugging
** [[https://www.gnu.org/software/gdb/][GDB - GNU Debugger]]

* Data types
** ~int~'s
   An /integer/ (32 bits) can be either negative/positive or only positive when using an
   ~unsigned int~ vs an ~int~. There is also ~float~ and ~double~ to represent decimal
   numbers.

** ~char~'s (8 bits)
   can only be represented with single quotes.

** ~array~'s, strings
   - *array* :: a contiguous chunk of memory elements of the same type
   - *string* :: an /array of characters/, terminated by the /null* char/ ~\0~

   The string keyword is syntactic sugar for a bit more complex representation of ~char *s~,
   a pointer to the memory location of the first character of the string.

** ~struct~'s
   is a composite data type (record) to multiple variables under a name in a block of
   memory, allowing the variables to be accessed via a single pointer. For example:
   hard-drive entries, patient information, ...

   #+NAME: first structure
   #+BEGIN_SRC c
   struct person {
     string name;
     string age;
   }

   struct person ana;
   #+END_SRC

   #+NAME: defining a custom type
   #+BEGIN_SRC c
   typedef struct {
     string name;
     string age;
   } person;

   person ana;
   #+END_SRC

   Accessing members of a struct on a stack is done via ~person.name~, while on the heap you
   need to dereference the struct first before accessing the member (~(*person).name~) or
   ~person->name~. The arrow dereferences /person/ and then access /name/.

** ~FILE*~'s
   is a ~struct~ data type which has been defined in the standard library ~stdio.h~ and is
   used to store *persistent data*, data that doesn't disappear when the program exits.

*** Opening/closing
    - ~fopen(fileName, operation)~ :: opens a file and returns a file pointer (always check
         for ~NULL~)
    - ~fclose(filePointer)~ :: closes the file pointed to by the given pointer

*** Reading/writing (inefficient)
    - ~fgetc(filePointer)~ :: reads and returns the next character from the file pointed to.
         The last character of the file is ~EOL~.
    - ~fputc(character, filePointer)~ :: writes are appends the character to the pointed-to
         file.

    #+NAME: An equivalent of the cp-command in Linux
    #+BEGIN_SRC c
    char c;
    while((c = fgetc(ptr)) != EOF) fputc(c, ptr2);
    #+END_SRC

*** Reading/writing (a bit more efficient)
    - ~fread(buffer, size, qty, filePointer)~ :: reads ~qty~ units of size ~size~ from the file
         pointed to and stores it in a memory buffer (array) pointed to by ~buffer~.
    #+BEGIN_SRC c
    int arr[10];
    fread(arr, sizeof(int), 10, ptr)
    #+END_SRC

    - ~fwrite(buffer, size, qty, filePointer)~ :: writes ~qty~ units of size ~size~ to the
         file pointed to by reading them from a buffer (array) pointed to by ~buffer~.
    #+BEGIN_SRC c
    int arr[10]; // imagine the array being filled up with data
    fwrite(arr, sizeof(int), 10, ptr)
    #+END_SRC

* Pointers & Memory
** Pointers
   are data items, where the /value/ is a memory address and the /type/ describes the data
   located at the memory address. Therefore pointers allow data structures and/or
   variables to be shared among functions.

   The ~*~ has a different meaning when used in a declaration and an expression.
   - ~char *t~ :: declares a variable t, pointing to another variable type ~char~
   - ~char c = *s~ :: read the value from the address stored in s and store it in c

   In order to pass in the address of a certain memory location into a pointer, we need
   to extract the address from the variable.
   #+BEGIN_SRC c
   int k = 5;
   int *pk; // equivalent to int *pk = &k
   pk = &k; // passes the address of k into pk
   #+END_SRC

   Swapping two variables, via a swap-function, doesn't work without sending the address
   of the integers, because all data types (except arrays) are sent in as a copy of the
   value, NOT the actual variable.
   #+BEGIN_SRC c
   #include <stdio.h>

   void swap(int *a, int *b);

   int main(void)
   {
     int x = 1;
     int y = 2;

     swap(&x, &y);
     // x = 2, y = 1
   }

   void swap(int *a, int *b)
   {
     int tmp = *a;
     *a = *b;
     *b = tmp;
   }
   #+END_SRC
** Simplified representation of memory
  is kinda like a huge array of elements, where each element is ~1 byte~. Memory addresses
  are typically represented in *hexadecimal*

  |-----------------------|
  | text                  |
  |-----------------------|
  | initialized data      |
  |-----------------------|
  | unitialized data      |
  |-----------------------|
  | heap                  |
  |                       |
  |                       |
  | stack                 |
  |-----------------------|
  | environment variables |
  |-----------------------|
** (Call) Stack
   is primarily used to keep track of the point to which each active subroutine should
   return control when it finishes executing.

   Each stack frame usually includes the arguments passed into the function, the return
   address back to the caller and space for local variables.
   Once the function is returned, these local variables are destroyed.

** Heap
   region of the computer's memory that is not managed automatically, and is not as
   tightly managed by the CPU. Ideal to store data that needs to be globally accessible.

   The heap is where blocks of dynamically allocated memory are stored, which can be
   accessed at runtime. ~malloc~ is a C standard library function that creates an amount of
   memory and returns the address to the beginning of the reserved memory chunk.

   Beware of garbage values, since it doesn't clear the memory. If ~malloc~ can't give
   memory it returns a ~NULL~ pointer.

   #+BEGIN_SRC c
   // allocate memory
   char *t = malloc(5); // allocates a char pointee of length 5 and point t to pointee

   // later to free the memory
   free(t)
   #+END_SRC

** Stack/Heap/Buffer Overflow
*** Contrived example
    It's possible to overwrite/access memory, which you arent't supposed to touch, when
    allocating not enough memory for all possible cases of the program. The example below
    makes it possible to overwrite memory outside of stack. A clever person could try
    injecting a malicious program and overwriting the return address.
    memory of the array
    #+BEGIN_SRC c
      #include <string.h>

      void foo(char *bar)
      {
        char c[12];
        memcpy(c, bar, strlen(bar));
      }

      int main(int argc, char *argv[])
      {
        foo(argv[1]);
      }
    #+END_SRC

*** Prevention/Debugging
    ~valgrind()~ helps catching possible memory bugs and makes sure all reserved memory via
    ~malloc()~, was also ~free()~'d at some point.

* Special Functions
** ~crypt~
    is a C [[https://en.wikipedia.org/wiki/Data_Encryption_Standard][DES (Data Encryption Standard)]]-based (symmetric-key algorithm) function which
    can encrypt a certain password, by giving it a password and some salt. That
    means the function returns the same hashed value for a certain password. The salt we
    need to apply are the first two characters of the hashed password.
** ~sprintf~
   stores a formatted string along the lines of format inside a ptr.

   Note how ~%03i~ tells the formatter to always show an integer with 3
   numbers, formatted as XXX.jpg, by prepending zero's if they need it.
   ~sprintf(fileName, "%03i.jpg", someInteger)~;

* Data structures
** Summary
*** Arrays
   - modifying an array is bad
   - sorting is easy
   - lookup is constant time

*** Linked List
    - modifying is easy
    - lookup is bad
    - difficult to sort

*** Hash tables
    - insertion is two-step (hash + add)
    - deletion is easy
    - average lookup is better than linked list
    - sucks at sorting

*** Tries
    - Insertion is complex - dyanmic memory allocation
    - deletion is easy
    - lookup is fast
    - already sorted
    - rapidly becomes huge, not great if space is premium

** [[https://en.wikipedia.org/wiki/Linked_list][Linked list]]
   is a collection of nodes, which together represent a sequence. Each node contains *data*
   and a *reference* (link) to the next node in the sequence. Depending if the list needs to
   stay sorted or not, the running time is $O(n)$ or $O(1) respectively.

   Be careful when inserting an item as the first element in the list. Always let the new
   item point to the firs item in the list, before moving the head (the pointer pointing
   to the beginning of the linked list).

   #+NAME: Unique list
   #+BEGIN_SRC c
     #include <cs50.h>
     #include <stdio.h>

     typedef struct ll
     // the struct needs a name, before the typedef when referencing itself
     {
       int number;
       struct ll *next;
     } node;

     int main(void)
     {
       // memory for numbers
       node *numbers = NULL;

       // Prompt for numbers (until EOF)
       while (true)
         {
           // Prompt for number
           int number = get_int("number: ");

           // Check for EOF
           if (number == INT_MAX)
             {
               break;
             }

           // Check whether number is already in list
           bool found = false;
           for (node *ptr = numbers; ptr != NULL; ptr = ptr->next)
             {
               if (ptr->number == number)
                 {
                   found = true;
                   break;
                 }
             }

           // If number not found in list, add to list
           if (!found)
             {
               // Allocate space for number
               node *n = malloc(sizeof(node));
               if (!n)
                 {
                   return 1;
                 }

               // Add number to list
               n->number = number;
               n->next = NULL;
               if (numbers)
                 {
                   for (node *ptr = numbers; ptr != NULL; ptr = ptr->next)
                     {
                       if (!ptr->next)
                         {
                           ptr->next = n;
                           break;
                         }
                     }
                 }
               else
                 {
                   numbers = n;
                 }
             }
         }

       // Print numbers
       printf("\n");
       for (node *ptr = numbers; ptr != NULL; ptr = ptr->next)
         {
           printf("%i\n", ptr->number);
         }

       // Free memory
       node *ptr = numbers;
       while (ptr != NULL)
         {
           node *next = ptr->next;
           free(ptr);
           ptr = next;
         }
     }
   #+END_SRC

** [[https://en.wikipedia.org/wiki/Hash_table][Hash table]]
   combines a *hash function*, which returns some code and an *array* capable of storing data
   we want to place in the data structure. In other words: Run the data through the hash function and store the dat in the element
   of the array represented by the return hash code.

   Typically you'd want to use chaining via linked lists to avoid collision. So it's best
   used for unsorted data.

*** Hash functions best practices
    - use all of the data
    - pure function (given an input, give always the same output)
    - uniformly distrubute data
    - generate different hash for similar data (not sure why?)

** [[https://en.wikipedia.org/wiki/Trie][Trie]] (pronounced try)
   is short for /retrieval/, which essentially is a tree with an array as each of it's
   children. Each of those children potentially can have arrays as their children, etc.

   Not memory efficient, it's time constant $O(1)$, so given an insane amount of data,
   it'll always perform the same amount of steps to look up a specific name. Very
   performant even when looking up specefic data.

   #+BEGIN_SRC c
     typedef struct _trie
     {
       char planet[20];
       struct _trie paths[10];
     } trie;
   #+END_SRC

** Stack & Queues
   The data structure could be implemented via a linked list. Be careful to not lose the
   reference of the first element of the list, when performing adding or removing items.

   - [[https://en.wikipedia.org/wiki/Stack_(abstract_data_type)][Stack]] :: has a mechanism to *push* elements in and *pop* elements out again in a *LIFO*
   (Last-In-First-Out) manner.
   #+BEGIN_SRC c
     typedef struct
     {
       int *numbers;
       int size;
     } stack;
   #+END_SRC

   - [[https://en.wikipedia.org/wiki/Queue_(abstract_data_type)][Queue]] :: keeps the entities in the collection in order by using *FIFO*
        (First-In-First-Out).
   #+BEGIN_SRC c
     typedef struct
     {
       int front;
       int *numbers;
       int size;
     } queue;
   #+END_SRC

** [[https://en.wikipedia.org/wiki/Binary_search_tree][Binary search tree]]
    is binary tree, which stores a key/value and each have two sub-tree (left and right).
    Each key in the node mut be greater than or equal to any key stored in the left tree.
    #+NAME: definition
    #+BEGIN_SRC c
      typedef struct node
      {
        int n;
        struct node *left;
        struct node *right;
      }
      node;
    #+END_SRC

    #+NAME: searching
    #+BEGIN_SRC c
      bool search(int n, node *tree)
      {
        if (tree == NULL)
        {
          return false;
        }
        else if (n < tree->n)
        {
          return search(n, tree->left);
        }
        else if (n > tree->n)
        {
          return search(n, tree->right);
        }
        else
        {
          return true;
        }
      }
    #+END_SRC
