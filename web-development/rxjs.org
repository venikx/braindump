#+TITLE: RxJS
#+AUTHOR: AnaRobynn
#+FILETAGS: :javascript:rx:rxjs:
#+STARTUP: hideblocks

* Resources
  - [[https://github.com/btroncone/learn-rxjs/tree/master/operators][RxJS Operators by Example]]
  - [[http://reactivex.io/rxjs/manual/overview.html#operators][RxJS Docs]]

* Asynchronous Programming: The End of The Loop
** Reduce
   1. Flattening arrays
      #+BEGIN_SRC javascript
        Array.prototype.concatAll = function() {
            var results = []

            this.forEach(function(subArray) {
                subArray.forEach(function(item) {
                    results.push(item)
                });
            });

            return results
        };
      #+END_SRC

   2. Composing functions
      #+BEGIN_SRC javascript
        const increment = input => input++
        const decrement = input => input--

        let initial_value = 1

        const pipeline = [
            increment,
            increment,
            increment,
            decrement
        ]

        const final_value = pipeline.reduce((acc, fn) => fn(acc), initial_value)
        const reversed = pipeline.reduceRight((acc, fn) => fn(acc), initial_value)
      #+END_SRC
      
** Map
   The trick with [[https://egghead.io/lessons/javascript-advanced-flattening][Advanced Flattening]] deeply nested structures is to keep
   nesting expression untill the closures provide enough variables to create the
   flattened result.
   NOTE: Returning an array inside map creates a multi-dimensional array and it
   should be flattened n-1 times.
   #+BEGIN_SRC javascript
     const exchanges = [
         { 
             name: "NYSE",
             stocks: [
                 { 
                     symbol: "XFX", 
                     closes: [
                         { date: new Date(2014,11,24), price: 240.10 },
                         { date: new Date(2014,11,23), price: 232.08 },
                         { date: new Date(2014,11,22), price: 241.09 }
                     ]
                 },
                 { 
                     symbol: "TNZ", 
                     closes: [
                         { date: new Date(2014,11,24), price: 521.24 },
                         { date: new Date(2014,11,23), price: 511.00 },
                         { date: new Date(2014,11,22), price: 519.29 }     
                     ]
                 },
             ]
         },
         { 
             name: "TSX",
             stocks: [
                 { 
                     symbol: "JXJ", 
                     closes: [
                         { date: new Date(2014,11,24), price: 423.22 },
                         { date: new Date(2014,11,23), price: 424.84 },
                         { date: new Date(2014,11,22), price: 419.72 }
                     ]
                 },
                 { 
                     symbol: "NYN", 
                     closes: [
                         { date: new Date(2014,11,24), price: 16.82 },
                         { date: new Date(2014,11,23), price: 16.12 },
                         { date: new Date(2014,11,22), price: 15.77 }
                     ]
                 },
             ]
         }
     ]

     const christmasEveCloses = 
         exchanges
         .map(exhange => exchange.stocks
              .map(stock => stock.closes
                   .filter(close => {
                       return close.date.getMonth() === 12 &&
                           close.date.getDate() === 24;
                   }).map(close => ({
                       symbol: stock.symbol,
                       price: close.price
                   }))
                  ).concatAll()
             ).concatAll()
   #+END_SRC

* The RxJS way of life
  It's a sign the logic is not implemented in a RxJS way if manual
  unsubscription is used a lot. 
  
  Completed observables, can't be restarted, re-subscription is needed ~repeat()~.
  
  Don't create hot observables, when sharing the execution doesn't make any
  sense. For example, using ~Math.random()~
  #+BEGIN_SRC javascript
    const clock$ = Rx.Observable.interval(500).share().take(6); // shares the creation of the interval
    const randomNum$ = clock$
      .map(i => Math.random() * 100).share(); // shares the creation for the random generated numbers
                                              // if not, results are different, because of the non-shared execution
  #+END_SRC
  
* Beyond the Basics: Creating Observables from scratch
** Creating observables
  Observables are a lot like functions with multiple return values. Don't
  confuse observables with event emitters.

  #+BEGIN_SRC javascript
    // functions
    const foo = () => 1;
    foo.call()

    // observables
    const numberGen$ = Rx.Observable.create(observer => {
        try {
            observer.next(1)
            observer.next(2)
            observer.complete()
        } catch (err) {
            observer.error(new Error("Not a number"))
        }
    return; //dispose here
    })

    numberGen$.subscribe() 
  #+END_SRC
   
** Observer
   is the consumer of the values delivered by an Observable.
   An observer is an object with three callbacks (next, error and complete)
   which are also the types of notifications delivered by the Observable.

** Subscription
   is an object, which represents a disposable resource, usually the execution
   of an observable. Usually only has ~unsubscribe()~ as a method. Calling the
   unsubscribe method should dispose the observable and release all resources.

** Subject
   is both observer and observable. 
   1. Subscribing to a Subject doesn't invoke a new execution, but simply
      registers the observer is a list of observers.
   2. Adding the Subject as an observer to an Observable has the benefit of
      multicasting the observed values to the observers of the Subject.
      
   A subject NEVER triggers execution when it has been completed. 
   In order to restart a multicasted observable, after an observer re-connects,
   a new instance of the Subject has to be used before execution starts again. A
   common pattern for this is using a /subjectFactor/  
   
   #+BEGIN_SRC javascript
     function subjectFactory() {
         return new Rx.BehaviorSubject(false); 
     }

     const foo = Rx.Observable.interval(1000).take(5)
           .multicast(subjectFactory)
           .refCount()
           .scan(currState => !currState)

     foo.subscribe(x => console.log(x)) 
     setTimeout(() => foo.unsubscribe(), 5000)
     // this will re-execute the shared observable
     setTimeout(() => foo.subscribe(), 10000)  
   #+END_SRC
      
** Operators
   when called, do not change the existing Observable instance, but return a new
   Observable, whose subscription logic is based on the first Observable.
   => pure operation
   
   As soon as we invoke the observable, by subscribing to it, each operator will
   invoke it's subscription to the source of the previous observable and so on.
   
   #+BEGIN_SRC javascript
     const foo = Rx.Observable.of(1)

     Rx.Observable.prototype.add = function (amount) {
         const source = this
         const result = Rx.Observable.create(function subscribe(observer) {
             source.subscribe(
                 x => { observer.next(x + amount) },
                 err => { observer.error(err) },
                 () => { observer.complete() }
             )
             // the subscription subscribes to the source observable, while modifying the data
             // without mutating the source
         })
         return result
     }
     foo.add(4).subscribe(console.log) // 5
   #+END_SRC

* Multicasting Operators
  different Subjects is very common, which is why RxJS provides us some
  operators, which automatically disconnect the multicasted observable when no-one
  is listening (to prevent memory leaks).
  
  #+BEGIN_SRC javascript
    var foo = Rx.Observable.interval(1000)
    // .publish() = .multicast(new Rx.Subject())
    // .publishReplay() = .multicast(new Rx.ReplaySubject())
    // .publishLast() = .multicast(new Rx.AsyncSubject())
        .publishBehavior(false) // = .multicast(new Rx.BehaviorSubject(false))
        .refCount()
    // .share() = .multicast(new Rx.Subject()).refCount()

    foo
        .scan(currState => !currState)
        .subscribe(x => console.log(x))

    setTimeout(() => foo.unsubscribe(), 5000) 
  #+END_SRC

* Effectively use higher-order observables
** ~switchMap()~
   is an epic tool with many built-in features:
   - composing via closures (selector function)
   - network cancellation (due to the fact in unsubscribes, when receiving
     another observable
   - promise convertion
   #+BEGIN_SRC javascript
     const clickObservable = Rx.Observable
           .fromEvent(document, 'click')

     function performRequest() {
         return fetch('https://jsonplaceholder.typicode.com/users/1')
             .then(res => res.json())
     }

     const responseObservable = clickObservable
           .switchMap(click => performRequest(), (click, res) => res.email)
   #+END_SRC

** ~groupBy()~
   branches out out multiple higher-order observables by evaluating each item
   and assigning a key to each higher-order observable. 
   Super powerful tool when dealing with a large, dynamic dataset.
   #+BEGIN_SRC javascript
     const busObservable = Rx.Observable.of(
         {code: 'en-us', value: '-TEST-'},
         {code: 'en-us', value: 'hello'},
         {code: 'es', value: '-TEST-'},
         {code: 'en-us', value: 'amazing'},
         {code: 'pt-br', value: '-TEST-'},
         {code: 'pt-br', value: 'olÃ¡'},
         {code: 'es', value: 'hola'},
         {code: 'es', value: 'mundo'},
         {code: 'en-us', value: 'world'},
         {code: 'pt-br', value: 'mundo'},
         {code: 'es', value: 'asombroso'},
         {code: 'pt-br', value: 'maravilhoso'}
     ).concatMap(x => Rx.Observable.of(x).delay(500));

     const all = busObservable
           .groupBy(obj => obj.code) // creates multiple observables differentiated by the code
           .mergeMap(codeObs => codeObs // acces to codeObs
                     .skip(1)  // each inner observable won't emit the first value
                     .map(obj => obj.value) // gets mapped to the value
                    ); // flatten
   #+END_SRC

