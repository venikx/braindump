#+TITLE: Javascript
#+AUTHOR: AnaRobynn
#+FILETAGS: :javascript:
#+STARTUP: hideblocks

Related: [[file:html.org][wiki:Browser, DOM and CSS]], [[file:linux.org][wiki:Linux]]

* Functional Programming
  The soul of fp is the separation of concerns and recognition of common
  patterns. Learning fp is daunting, but don't give up.

*** Resources
    - [[https://drboolean.gitbooks.io/mostly-adequate-guide/content/][Professor Frisby's Mostly Adequate Guide to Functional Programming]]

*** Symptoms of code that fp could solve
    - Custom names
    - Looping patterns
    - Glue Code
    - Side effects

****

* Testing
** [[https://github.com/substack/tape][Testing with Tape]]

* Nodejs
** Background
*** History
   Lots of drama, people didn't like it. People didn't care for JSON, until social media
   became big. Node and Mongo solved each other's problems. Google invited Ryan Dahl to
   speak at their conference.
   Node became very popular due to interesting npm packages like express.js, mongoose,
   angularjs, ... but that's also the pitfall of Node (or actually npm). People found node
   interesting not for the async, event driven nature, but for the massive amount of
   packages.

*** What is it?
   A C++ application, which embeds the V8 engine. The V8 engine is the Chrome javascript
   interpreter. Node continuously checks the "event loop" on each tick, searching for new
   tasks. As soon soon as the tasks are done, node exits.

   Node is single-threaded, but tasks can be scheduled to be performed later, which avoids
   blocking IO.

   1. Reads the file + dependencies
   2. Executes synchronous tasks
   3. Executes asynchronous tasks as soon as they are ready by looking at the event loop

*** Conventions
   - ENV variables
   - test/ directory
   - readme in root directory
   - code comments
     - @Param
     - @TODO
   - airbnb linting
   - error handling
     #+BEGIN_SRC javascript
       jedi(function(err, data){
         // check error
         // do some stuff
       })
     #+END_SRC

* Reactive Programming (RxJS)
** Resources
  - [[https://github.com/btroncone/learn-rxjs/tree/master/operators][RxJS Operators by Example]]
  - [[http://reactivex.io/rxjs/manual/overview.html#operators][RxJS Docs]]
  - [[http://reactivex.io/rxjs/manual/overview.html][Introduction to RxJS]]

** Asynchronous Programming: The End of The Loop
*** Reduce
   1. Flattening arrays
      #+BEGIN_SRC javascript
        Array.prototype.concatAll = function() {
            var results = []

            this.forEach(function(subArray) {
                subArray.forEach(function(item) {
                    results.push(item)
                });
            });

            return results
        };
      #+END_SRC

   2. Composing functions
      #+BEGIN_SRC javascript
        const increment = input => input++
        const decrement = input => input--

        let initial_value = 1

        const pipeline = [
            increment,
            increment,
            increment,
            decrement
        ]

        const final_value = pipeline.reduce((acc, fn) => fn(acc), initial_value)
        const reversed = pipeline.reduceRight((acc, fn) => fn(acc), initial_value)
      #+END_SRC

*** Map
   The trick with [[https://egghead.io/lessons/javascript-advanced-flattening][Advanced Flattening]] deeply nested structures is to keep
   nesting expression untill the closures provide enough variables to create the
   flattened result.
   NOTE: Returning an array inside map creates a multi-dimensional array and it
   should be flattened n-1 times.
   #+BEGIN_SRC javascript
     const exchanges = [
         {
             name: "NYSE",
             stocks: [
                 {
                     symbol: "XFX",
                     closes: [
                         { date: new Date(2014,11,24), price: 240.10 },
                         { date: new Date(2014,11,23), price: 232.08 },
                         { date: new Date(2014,11,22), price: 241.09 }
                     ]
                 },
                 {
                     symbol: "TNZ",
                     closes: [
                         { date: new Date(2014,11,24), price: 521.24 },
                         { date: new Date(2014,11,23), price: 511.00 },
                         { date: new Date(2014,11,22), price: 519.29 }
                     ]
                 },
             ]
         },
         {
             name: "TSX",
             stocks: [
                 {
                     symbol: "JXJ",
                     closes: [
                         { date: new Date(2014,11,24), price: 423.22 },
                         { date: new Date(2014,11,23), price: 424.84 },
                         { date: new Date(2014,11,22), price: 419.72 }
                     ]
                 },
                 {
                     symbol: "NYN",
                     closes: [
                         { date: new Date(2014,11,24), price: 16.82 },
                         { date: new Date(2014,11,23), price: 16.12 },
                         { date: new Date(2014,11,22), price: 15.77 }
                     ]
                 },
             ]
         }
     ]

     const christmasEveCloses =
         exchanges
         .map(exhange => exchange.stocks
              .map(stock => stock.closes
                   .filter(close => {
                       return close.date.getMonth() === 12 &&
                           close.date.getDate() === 24;
                   }).map(close => ({
                       symbol: stock.symbol,
                       price: close.price
                   }))
                  ).concatAll()
             ).concatAll()
   #+END_SRC

** The RxJS way of life
  It's a sign the logic is not implemented in a RxJS way if manual
  unsubscription is used a lot.

  Completed observables, can't be restarted, re-subscription is needed ~repeat()~.

  Don't create hot observables, when sharing the execution doesn't make any
  sense. For example, using ~Math.random()~
  #+BEGIN_SRC javascript
    const clock$ = Rx.Observable.interval(500).share().take(6); // shares the creation of the interval
    const randomNum$ = clock$
      .map(i => Math.random() * 100).share(); // shares the creation for the random generated numbers
                                              // if not, results are different, because of the non-shared execution
  #+END_SRC

** Beyond the Basics: Creating Observables from scratch
*** Creating observables
  Observables are a lot like functions with multiple return values. Don't
  confuse observables with event emitters.

  #+BEGIN_SRC javascript
    // functions
    const foo = () => 1;
    foo.call()

    // observables
    const numberGen$ = Rx.Observable.create(observer => {
        try {
            observer.next(1)
            observer.next(2)
            observer.complete()
        } catch (err) {
            observer.error(new Error("Not a number"))
        }
    return; //dispose here
    })

    numberGen$.subscribe()
  #+END_SRC

*** Observer
   is the consumer of the values delivered by an Observable.
   An observer is an object with three callbacks (next, error and complete)
   which are also the types of notifications delivered by the Observable.

*** Subscription
   is an object, which represents a disposable resource, usually the execution
   of an observable. Usually only has ~unsubscribe()~ as a method. Calling the
   unsubscribe method should dispose the observable and release all resources.

*** Subject
   is both observer and observable.
   1. Subscribing to a Subject doesn't invoke a new execution, but simply
      registers the observer is a list of observers.
   2. Adding the Subject as an observer to an Observable has the benefit of
      multicasting the observed values to the observers of the Subject.

   A subject NEVER triggers execution when it has been completed.
   In order to restart a multicasted observable, after an observer re-connects,
   a new instance of the Subject has to be used before execution starts again. A
   common pattern for this is using a /subjectFactor/

   #+BEGIN_SRC javascript
     function subjectFactory() {
         return new Rx.BehaviorSubject(false);
     }

     const foo = Rx.Observable.interval(1000).take(5)
           .multicast(subjectFactory)
           .refCount()
           .scan(currState => !currState)

     foo.subscribe(x => console.log(x))
     setTimeout(() => foo.unsubscribe(), 5000)
     // this will re-execute the shared observable
     setTimeout(() => foo.subscribe(), 10000)
   #+END_SRC

*** Operators
   when called, do not change the existing Observable instance, but return a new
   Observable, whose subscription logic is based on the first Observable.
   => pure operation

   As soon as we invoke the observable, by subscribing to it, each operator will
   invoke it's subscription to the source of the previous observable and so on.

   #+BEGIN_SRC javascript
     const foo = Rx.Observable.of(1)

     Rx.Observable.prototype.add = function (amount) {
         const source = this
         const result = Rx.Observable.create(function subscribe(observer) {
             source.subscribe(
                 x => { observer.next(x + amount) },
                 err => { observer.error(err) },
                 () => { observer.complete() }
             )
             // the subscription subscribes to the source observable, while modifying the data
             // without mutating the source
         })
         return result
     }
     foo.add(4).subscribe(console.log) // 5
   #+END_SRC

** Multicasting Operators
  different Subjects is very common, which is why RxJS provides us some
  operators, which automatically disconnect the multicasted observable when no-one
  is listening (to prevent memory leaks).

  #+BEGIN_SRC javascript
    var foo = Rx.Observable.interval(1000)
    // .publish() = .multicast(new Rx.Subject())
    // .publishReplay() = .multicast(new Rx.ReplaySubject())
    // .publishLast() = .multicast(new Rx.AsyncSubject())
        .publishBehavior(false) // = .multicast(new Rx.BehaviorSubject(false))
        .refCount()
    // .share() = .multicast(new Rx.Subject()).refCount()

    foo
        .scan(currState => !currState)
        .subscribe(x => console.log(x))

    setTimeout(() => foo.unsubscribe(), 5000)
  #+END_SRC

** Effectively use higher-order observables
*** ~switchMap()~
   is an epic tool with many built-in features:
   - composing via closures (selector function)
   - network cancellation (due to the fact in unsubscribes, when receiving
     another observable
   - promise convertion
   #+BEGIN_SRC javascript
     const clickObservable = Rx.Observable
           .fromEvent(document, 'click')

     function performRequest() {
         return fetch('https://jsonplaceholder.typicode.com/users/1')
             .then(res => res.json())
     }

     const responseObservable = clickObservable
           .switchMap(click => performRequest(), (click, res) => res.email)
   #+END_SRC

*** ~groupBy()~
   branches out out multiple higher-order observables by evaluating each item
   and assigning a key to each higher-order observable.
   Super powerful tool when dealing with a large, dynamic dataset.
   #+BEGIN_SRC javascript
     const busObservable = Rx.Observable.of(
         {code: 'en-us', value: '-TEST-'},
         {code: 'en-us', value: 'hello'},
         {code: 'es', value: '-TEST-'},
         {code: 'en-us', value: 'amazing'},
         {code: 'pt-br', value: '-TEST-'},
         {code: 'pt-br', value: 'olá'},
         {code: 'es', value: 'hola'},
         {code: 'es', value: 'mundo'},
         {code: 'en-us', value: 'world'},
         {code: 'pt-br', value: 'mundo'},
         {code: 'es', value: 'asombroso'},
         {code: 'pt-br', value: 'maravilhoso'}
     ).concatMap(x => Rx.Observable.of(x).delay(500));

     const all = busObservable
           .groupBy(obj => obj.code) // creates multiple observables differentiated by the code
           .mergeMap(codeObs => codeObs // acces to codeObs
                     .skip(1)  // each inner observable won't emit the first value
                     .map(obj => obj.value) // gets mapped to the value
                    ); // flatten
   #+END_SRC

* Angular
** Dependency Injection
*** Why?
   A __data service__ abstracts away the data, which implies the component
   only cares about the data provided by the service whatever the implementation
   is (hardcoded, during tests, network requests,...).

*** How?
   The provide is a `token` (used in constructors to ask for DI) and the
   implementation of the class is defined with `useClass`, which is extremely valuable
   when testing components.
   1. Type
   #+BEGIN_SRC javascript
     // component declaration
     @Component({
         moduleId: module.id,
         selector: 'list-component',
         template: ` ... `,
         providers: [
             { provide: MyService, useClass: MyService }
         ]
     })

     // add in constructor
     constructor(private service: MyService){}
   #+END_SRC
   1. Object
   #+BEGIN_SRC javascript
     // component declaration
     @Component({
         moduleId: module.id,
         selector: 'list-component',
         template: ` ... `,
         providers: [
             { provide: 'mimimi', useClass: MyService }
         ]
     })

     // inject in the constructor
     constructor(@Inject('mimimi') private service){}
   #+END_SRC

*** Factory Providers?
  Abstract away certain dependencies (some sort of IoC, inversion of control)

  Example:
  Injecting a service without being dependent on Angular's DI
  #+BEGIN_SRC javascript
        // logger
        export class LogDebugger {
            constructor(private enabled: boolean) {}

            debug(message) {
                if (this.enabled) {
                    console.log(`DEBUG: ${message}`);
                }
            }
        }

        // providers
        providers: [
            DataService,
            ConsoleService,
            {
                provide: LogDebugger,
                useFactory: (consoleService, secondService) => {
                    return new LogDebugger(consoleService, true);
                },
                // order matters here
                deps: [ConsoleService, SecondService]
            }
        ]
  #+END_SRC

*** ~@Injectable()~
   is needed, because Typescript only emits metadata when there is at least one
   decorator on a class. Angular needs those type annotations when transpiled to
   ES5 for Dependency Injection to work.

** Components
*** Pipes
**** How?
    Under the hood a poor man's pipe can be implemented with a reduce.
    #+BEGIN_SRC javascript
      const person  = {
          name: 'ana robynn'
      };

      const filters = {
          'deslugify': x => x.replace('-', ' '),
          'uppercase': x => x.toUpperCase()
      };

      // => becomes ANA ROBYNN
      const input    = 'name | deslugify | uppercase';
      // [name, deslugify, uppercase]
      const sections = input.split('|').map(x => x.trim());
      const ref      = person[sections[0]];
      const output   = sections
          .slice(1)
          .reduce((prev, next) => {
              if (filters[next]) {
                  return filters[next].call(null, prev);
              }
              return prev;
          }, ref);
    #+END_SRC

**** Async Pipe
    Each *async pipe* subscribes to an observable and will each have there own
    execution flow (risk of multiple network requests).

    => ReplaySubject
    Acts as an observer for the pipe and subscribes to the one network call.
   #+BEGIN_SRC javascript
     @Component({
         template: `
     <h2>{{(contact$ | async).name}}</h2>
     <img [src]="(contact$ | async).image">
     `
     })
     export class ContactComponent {
         contact$ = new BehaviorSubject({name: 'Loading...', image: ''});
         constructor() {
             const api = 'https://starwars-json-server-ewtdxbyfdz.now.sh/';
             route.params
                 .map((p: any) => p.id)
                 .switchMap(id => http.get(api + 'people/' + id)
                     .map(res => res.json())
                     .map(contact =>
                          Object.assign({}, contact, {image: api + contact.image}))
                 )
             // all incoming values are passed on to all it's subscribers
                 .subscribe(this.contact$);
         }
     }
   #+END_SRC

* React
** Advanced Patterns
   Dispatching a change handler to the outside, when some component manages it's state
   internally. That's possible via React's ~setState(updater, [callback])~.

   #+BEGIN_SRC javascript
   setState(currentState => ({ text: 'lol' }), () => this.props.onChange(this.state.text))
   #+END_SRC

*** Compound Components
   *Compound components* have a similar philosophy as the ~<select>~ and ~<option>~ elements in
   HTML. Worthless alone, powerfull together, since the children can modify the state of
   the parent. Hiding away the abstraction.

   The simplest implementation includes ~React.cloneElement()~ and ~React.Children.map()~.
   However it's not flexible (the div breaks the cloning.

   Context provides (pun) a way to provide the props to the compound components, without
   cloning elements. A value change of the Provider triggers a render, so make sure the
   value doesn't get recreated every time.

   #+BEGIN_SRC javascript
   const Yo = () => (
     <Toggle onToggle={onToggle}>
       <Toggle.On>The button is on</Toggle.On>
       <Toggle.Off>The button is off</Toggle.Off>
       <div>
         <Toggle.Button />
       </div>
     </Toggle>
   )
   #+END_SRC

*** FaCC (Function as Child Components)
    By themselves not so powerfull. However, managing a component's state without
    implementing the rendering logic is insane.

    The Context API is good and simple example.
    #+BEGIN_SRC javascript
    <Consumer>
      {value = /* render something */}
    </Consumer>
    #+END_SRC

    Passing in custom event handler are tricky, because the internal state might respond
    to the same handler. The *prop getters* is a function exposed via the children to merge
    properties the user passes in with the internal ones.

    #+BEGIN_SRC javascript
    this.props.children({ getProps: ({ onClick, ..props}) => ({
      'aria-expanded: true,
      onClick: (...args) => {
        this.someInternalFunction();
        onClick(...args);
      }
    })})
    #+END_SRC

*** State management
    The *state reducer* (not redux) allows the library user to manipulate the internal state
    of the library component. A common case is preventing the internal state from
    updating, due to state changes higher up in the component tree.

    #+BEGIN_SRC javascript
    // user.js
    internalSetState(changes, callback) {
      this.setState(state => {
        const changesObject =
          typeof changes === 'function' ? changes(state) : changes
        const { type, ...reducedChanges } = // strip off type, because it's not state
          this.props.stateReducer(state, changesObject) || {}
        return Object.keys(reducedChanges).length
        ? reducedChanges
        : null // avoid unneeded rerenders
    }, callback)
  }
    #+END_SRC
