#+TITLE: Handmade Hero
#+AUTHOR: venikx
#+STARTUP: content, indent

* Resources
** Books
- [[https://www.amazon.com/Mathematics-Programming-Computer-Graphics-Third/dp/1435458869/ref=pd_sim_14_6?_encoding=UTF8&pd_rd_i=1435458869&pd_rd_r=03JCN0ZJNDAT89T9RDWD&pd_rd_w=3Qgen&pd_rd_wg=8Cvny&psc=1&refRID=03JCN0ZJNDAT89T9RDWD][Math for 3D Game Programming and Computer Science]]
- [[https://www.amazon.com/Primer-5th-Stanley-B-Lippman/dp/0321714113][C++ Primer]]
- [[https://www.amazon.com/Game-Programming-Patterns-Robert-Nystrom/dp/0990582906/ref=pd_sim_14_2?_encoding=UTF8&pd_rd_i=0990582906&pd_rd_r=4ACE7CH5N5S6J9NP64EF&pd_rd_w=XD1Tt&pd_rd_wg=yc1pf&psc=1&refRID=4ACE7CH5N5S6J9NP64EF][Game programming patterns]]
- [[https://www.amazon.com/Engine-Architecture-Third-Jason-Gregory/dp/1138035459/ref=sr_1_1?keywords=game+engine+architecture&qid=1563911648&s=books&sr=1-1][Game Engine Architecture, Third Edition]]
- [[https://www.amazon.com/Game-Coding-Complete-Fourth-McShaffry/dp/1133776574/ref=pd_sim_14_2?_encoding=UTF8&pd_rd_i=1133776574&pd_rd_r=9TQGA57P3Q0F85MAZXTP&pd_rd_w=i5EIx&pd_rd_wg=8Nb8o&psc=1&refRID=9TQGA57P3Q0F85MAZXTP][Game Coding Complete]]
- [[http://www.dataorienteddesign.com/dodbook/][Data Oriented Design - Richard Fabian]]

** Videos
- [[http://www.opowell.com/post/talks-that-changed-the-way-i-think-about-programming/][Talks that changed the way I think about programming]]
- [[https://www.youtube.com/watch?v=UwBl7Rnkt78][Storytime with Jonathan Blow]]
- [[https://www.youtube.com/watch?v=cTwh9oHcs1w][Making a game in C from scratch - Dan Zaidan]]
- [[https://www.gamefromscratch.com/page/Complete-Blender-Game-Art-Tutorial-From-zero-experience-to-2D-or-3D-game-ready-asset.aspx][Complete Blender Game Art Tutorial]]
- [[https://www.youtube.com/playlist?list=PLtg36xKlu60wk3buYHvAdtSbqPsvNgUDV][Thinking deeply about being a software engineer]]

** Inspiration
- [[https://all-things-andy-gavin.com/2011/02/02/making-crash-bandicoot-part-1/][Making Crash Bandicoot]]

* Day 000 - Intro to Windows
** Day 1
*** Entry point
Windows calls the ~WinMain~ [[https://msdn.microsoft.com/en-us/library/windows/desktop/ms633559(v=vs.85).aspx][(docs)]], which is the default entry point to execute the program. The header
/windows.h/ needs to be included when using windows specific keywords like ~HINSTANCE~ and
~OutputDebugStringA~ [[https://docs.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-outputdebugstringa][(docs)]].

It's not recommend to change the default entry point, because a wrong configuration can result in
linker errrors.

#+NAME: win32_handmade.cpp
#+BEGIN_SRC c
  #include <windows.h>

  int CALLBACK WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow)
  {
    OutputDebugStringA("Some function\n");
    return 0;
  };
#+END_SRC

*** Functions
A /forward function declaration/ notifies the compiler it's legal to call a function *without* the
function definition. The build might fail when the implementation of the function could not be found
during the linking process.

The /function definition/ is the implementation of the declared function.

During the *compilation* phase the compilers marks the unresolved function definitions.
During the *linking* phase, the linker will try to find the correct function defintions.

** Day 2
*** ASCII vs Unicode
ASCII = old.
Unicode = new and handles foreign languages and the characters.

Microsoft created macros which ran the code in Unicode or ANSI mode depending on the compiler
flags. Bypass these macros by directly calling the functions to avoid confusion when compiling in a
different mode. Example: ~OutputDebugString~ => ~OutputDebugStringA~.

*** Disassembly
Absolutely essential to rudimentary [[https://wordsandbuttons.online/you_dont_have_to_learn_assembly_to_read_disassembly.html][read assemly code]]. Learn to debug problems on a lower level and
understand exactly what the processor is doing when executing the code.

1. Set a breakpoint
2. Start in debug mode
3. Right-click > Go To Disassembly

#+BEGIN_SRC asm
    ;Test = 255;
  00031718  mov         byte ptr [Test],0FFh
    ;Test = Test + 1;
  0003171C  movzx       eax,byte ptr [Test]
  00031720  add         eax,1
  00031723  mov         byte ptr [Test],al
#+END_SRC

Putting values inside locations (variables) does not require the processor to do any calculations.
Incrementing an ~int~ to existing variables requires the processor to move it closer to the
processor's *register* to operate on them.

*** Registers
The /EAX/ register is 32-bit wide, which is more than a byte (used for a ~char~). The
lowest two bits of the /EAX/ can be pulled out via ~al~. The results from pulling the lowest two bits is
put back into the variable ~Test~.

** Day 3
*** Reading/Writing from/to memory is non-trivial
Accessing memory is slow, due to physics. Imagine a processor with a clock speed of 3,2 GHz, the
speed of light is \pm 300 000 m/s. The distance a photon is able to travel per second is not far!

\begin{equation}
d = \dfrac{ \pm 300000 m/s}{3,2Ghz}
d = \pm 9 cm
\end{equation}

The memory is about 9-10 cm away from the CPU, implying that the photon is not able to go to the
memory and back within 1 CPU cycle. CPU's reduce /latency/ by providing a super small cache on the CPU
itself (thus reducing the distance between CPU and memory).

/Bandwidth/ is bottlenecked by the components and their capability of sending as much stuff down the
wires per second, which is an easier problem.

*** Pointers (heap)
The ~*~ (star) in front of a variable notifies the compiler to free some memory to store the memory
location of another variable. The size of that /address/ is the same size as an ~int~ (for x64).
The ~&~ (ampersand) in front of a variable is the /address operator/, which gives back the address of a
variable stored in memory.

The address location is the location in the virtual memory, *not* the actual physical memory (only for
modern day systems). The /virtual memory/ prevents different programs accessing and modifying the same
piece of memory.

The CPU has a table which secretly maps the virtual memory of programs to the actual place in
physical memory.

*** Stack
is memory managed by the compiler/OS. Everytime a function gets invoked a new stack is created with
it's own environment like variables, etc.

Go to *Debug > Memory > Memory 1* and notice how a new stack changes the memory layout close to the
memory location of the previous stack?

** Day 4
*** Endianness
It's up to the CPU how to interpret/read values which span multiple bytes (such as ~short~, which is
represented by two bytes). The CPU knows how to add two bytes, to get the representation of a 16
bits, but there is no hard law on how to store it.
- little endian :: lowest byte of a value representation first (x86, arm, x64)
- big endian :: highest byte first (powerpc)

Important to remember the legacy, since some of the software today (like for example the ~.psd~ file
format is using /big endian/). It's not possible to load big endian data onto a little endian machine,
unless it passes through some conversion first.
The modern devices are using /little endian/ so it's generally not something to worry about too much.

*** ~struct~'s
declare a layout in memory, which holds a multitude of basic types as fields, which allows access to
it's member via the name of the struct.

The compiler is not constraint to lay each of the fields as compact as possible. A ~char~ might be
respresented by 4 bytes if the processor if it's optimized to access values on 4 bytes boundaries
(as it might be slower to access a single byte).

*** Casting
Be cautious. Casting values to a *higher* memory size results in garbage values being included.
Casting values to a *lower* memory size will chop the value, if the value is too big to be represented
by the low memory size.

** Day 5
*** How does code turn into an executable?
Code goes through a /compiler/, which spits out ~obj~ files. Together with ~lib~ files (obj files compared
together to form a group), such as system files, goes through the /linker/, which spits out a
Windows/Intel executable.

Microsoft defined the layout on disk for the executable file. The /header/ defines the properties of
the file (such as it being an ~.exe~), the /fixup table/ keeps all the references from where our program
calls into Windows and the /CPU specific code/ are all the instructions for the CPU.

*** How does Windows roughly run an executable?
Windows loads up the AMD/Intel specific instructions and put into the memory of the machine. The
missing code where Windows is supposed to patch the memory location with it's own code is found in
the fixup table. However, Windows doesn't actually reference to it's "real" memory where the Windows
code is held in memory. The memory address is obfuscated by Windows, since your program can only
call into it's own /Virtual Memory Address/ assigned by Windows.

* Day 001 - Setting up the Windows Build
** How does Windows calls our code?
It doesn't!
Windows kernels calls the CRT (C Runtime), which calls ~WinMain~ of our code.

** Windows dependencies
The MSDN pages document which lib needs to be important for each function.

Windows needs to bind to our code, find the places where we call Windows functions and patch those
with pointers to the location in memory where those functions are running at that time.

The functions coming from the /kernel/ don't require an /import library/ (Windows magic). ~WinMain~ is
part of those kernel functions. Calls to the UI system, requires building the project with specific
lib files. The /linker/ complains when these libraries are missing, since it doesn't know how to
insert certain functions when patching the Windows code.

** Automation with ~.bat~ files
*** Setting the ~env~
The ~cl~ command-line tool controls the Microsoft C/C++ compiler and linker and comes pre-installed
with Visual Studio 2019 (*check* the /C++ Desktop Environment/). The command is *not* exposed in the
/cmd.exe/ by default (sad).

#+NAME: setenv.bat
#+BEGIN_SRC bat
  @echo off

  call "C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build\vcvarsall.bat" x64
  REM set path=D:\Office\Documents\dev\handmade\misc;%path%
#+END_SRC

*** Building
A simplified version of more commonly known /make/ systems, such as ~gnu make~, ~ninja~ or ~cmake~. The
mantra being =Dumb and simple=, too much time is lost in complex build sytems. The /batch/ file will be
responsible for setting the environment and compiling all the code all the time.

According to Casey there is no need for compiling the modified files only to speed up the build
process if you program sanely.

#+NAME: build.bat
#+BEGIN_SRC bat
  @echo off

  mkdir ..\build
  pushd ..\build
  cl -Zi ..\code\win32_handmade.cpp user32.lib
  popd
#+END_SRC

** Debugging ~devenv~ (starts up Visual Studio)
Change the working dir of the ~win32_handmade~ start-up project to use the /root/ in stead of the /build\/
folder.

* Day 002 - Opening a Win32 Window
** [[https://docs.microsoft.com/en-us/windows/win32/learnwin32/creating-a-window][Creating a Window]]
Method of initialization:
- zero is initialization :: clear the whole struct to zero (used when performance is not a concern)
- contructors :: initializes values in the typical C++ way

The ~hInstance~ is either passed in from ~WinMain~ or retrieved by calling ~GetModuleHandle(0)~, which
asks the kernel for the window instance of the currently running code.

** [[https://docs.microsoft.com/en-us/windows/win32/learnwin32/window-messages][Handling Window messages]]
Notice the different between *sending* and *posting* a message. Posting puts the message in
the queue, which is handled by the ~WindowHandle~ => ~GetMessage~ => ~TranslateMessage~ => ~DispatchMessage~
flow. Sending skips the queue and the OS call the ~WNDPROC~ directly.

** [[https://docs.microsoft.com/en-us/windows/win32/learnwin32/writing-the-window-procedure][Writing the Window procedure]]
The ~WNDPROC~ passes incoming messages related to the program. These messages can be acted upon or
passed back to Windows if you don't want to handle them.

** [[https://docs.microsoft.com/en-us/windows/win32/learnwin32/painting-the-window][Paiting the Window]]
In stead of ~FillRect~, use [[https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-patblt][PatBlt]] to draw something fullscreen.

* Day 003 - Allocating a Backbuffer
** [[https://docs.microsoft.com/en-us/windows/win32/learnwin32/closing-the-window][Closing the Window]]
Things are better acquired and released in aggregate. Think of them as a group of resources, not as
a single resource. Create and release in waves.

** Different use cases for ~static~
Keyword ~static~'s use-case is context dependent:
1. Scope a function to a file (making it invisible for other files to import it)
2. Define it locally in a function to persist a value when the scope is recreated
3. Define it globally for everyone to be used

Good practice to give semantic meaning to those use-cases:
1. ~#define internal static~
2. ~#define local_persist static~
2. ~#define global_variable static~

** Naming conventions
Example: ~MainWindowCallback~ should become ~Win32MainWindowCallback~.

** How to draw stuff on the screen?
Handle ~WM_SIZE~, in which you call [[https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getclientrect][GetClientRect]] to receive the coordinates from the area where can
draw towards (meaning window - the windows close, minimize and maximize bar).

Use [[https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-stretchdibits][StretchDIBits]] /(DIB = Device Independant Bitmap)/ to pass in the memory location of your own
bitmap and ask Windows to copy/render the bitmap to the screen.
Why? => Reduces interfacing with the Windows api's to a minimum!

*** What is ~void *bitmapMemory~?
C doesn't have function overloading. [[https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createdibsection][CreateDIBSection]] only understand what type to give back once it
gets passed the arguments, so the pointer's data type is unknown.

* Day 004 - Animating the Backbuffer
** [[https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc][VirtualAlloc]]
Using ~StretchDIBits~, we don't need ~CreateDIBSection~, since we can create the memory ourselves. The
memory is allocated using the Windows allocater function in stead of ~malloc~, since you avoid going
through some of the C runtime library.

Free memory via [[https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualfree][VirtualFree]].

** Storing pixels in memory
RGB in memory is represented with 4 bytes, in stead of 3. It's more efficient to retrieve the memory
using 4 bytes, which why the colors are represented with an extra empty byte.

| Memory                    | RR GG BB xx |
| Loaded in (little endian) | xx BB GG RR |
| Microsoft preference      | xx RR GG BB |
| Memory                    | BB GG RR xx |

So when loading in RGB colors in memory on Microsoft, BB and RR need to swapped, so they are in the
correct order when looking on the registry.

Drawing the pixels on the screen is "as easy" is directly modifying the colors for pixels in
memory. The UpdateWindow takes care of actually putting the bitmap onto the window.

** [[https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-peekmessagea][PeekMessage]]
Changing from ~GetMessage~ is important, since it waits for an actual message to come by, which means
that our program doesn't loop during those "waiting times". ~PeekMessage~ on the other hand just
checks if something is in the queue and immediately return the event if there is something that
needs to be handled.

* Day 005 - Windows Graphics Review
Mainly used to review the week + clean up code.
- Global variables get bundled into a struct ~win32_offscreen_buffer~
- Only create the back buffer once, by moving it out of ~WM_SIZE~
- ~const~ is useless and doesn't exist in the compiler, because it can't know for sure if such
  variable won't be mutated

* Day 006 - Gamepad and Keyboard Input
