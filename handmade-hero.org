#+TITLE: Handmade Hero
#+AUTHOR: venikx
#+STARTUP: content, indent

* Resources
** Books
- [[https://www.amazon.com/Mathematics-Programming-Computer-Graphics-Third/dp/1435458869/ref=pd_sim_14_6?_encoding=UTF8&pd_rd_i=1435458869&pd_rd_r=03JCN0ZJNDAT89T9RDWD&pd_rd_w=3Qgen&pd_rd_wg=8Cvny&psc=1&refRID=03JCN0ZJNDAT89T9RDWD][Math for 3D Game Programming and Computer Science]]
- [[https://www.amazon.com/Primer-5th-Stanley-B-Lippman/dp/0321714113][C++ Primer]]
- [[https://www.amazon.com/Game-Programming-Patterns-Robert-Nystrom/dp/0990582906/ref=pd_sim_14_2?_encoding=UTF8&pd_rd_i=0990582906&pd_rd_r=4ACE7CH5N5S6J9NP64EF&pd_rd_w=XD1Tt&pd_rd_wg=yc1pf&psc=1&refRID=4ACE7CH5N5S6J9NP64EF][Game programming patterns]]
- [[https://www.amazon.com/Engine-Architecture-Third-Jason-Gregory/dp/1138035459/ref=sr_1_1?keywords=game+engine+architecture&qid=1563911648&s=books&sr=1-1][Game Engine Architecture, Third Edition]]
- [[https://www.amazon.com/Game-Coding-Complete-Fourth-McShaffry/dp/1133776574/ref=pd_sim_14_2?_encoding=UTF8&pd_rd_i=1133776574&pd_rd_r=9TQGA57P3Q0F85MAZXTP&pd_rd_w=i5EIx&pd_rd_wg=8Nb8o&psc=1&refRID=9TQGA57P3Q0F85MAZXTP][Game Coding Complete]]
- [[http://www.dataorienteddesign.com/dodbook/][Data Oriented Design - Richard Fabian]]

** Videos
- [[http://www.opowell.com/post/talks-that-changed-the-way-i-think-about-programming/][Talks that changed the way I think about programming]]
- [[https://www.youtube.com/watch?v=UwBl7Rnkt78][Storytime with Jonathan Blow]]
- [[https://www.youtube.com/watch?v=cTwh9oHcs1w][Making a game in C from scratch - Dan Zaidan]]
- [[https://www.gamefromscratch.com/page/Complete-Blender-Game-Art-Tutorial-From-zero-experience-to-2D-or-3D-game-ready-asset.aspx][Complete Blender Game Art Tutorial]]
- [[https://www.youtube.com/playlist?list=PLtg36xKlu60wk3buYHvAdtSbqPsvNgUDV][Thinking deeply about being a software engineer]]

** Inspiration
- [[https://all-things-andy-gavin.com/2011/02/02/making-crash-bandicoot-part-1/][Making Crash Bandicoot]]

* Day 000 - Intro to Windows
** Day 1
*** Additonal resources
- [[https://msdn.microsoft.com/en-us/library/windows/desktop/ms633559(v=vs.85).aspx][MSDN - WinMain]]
- [[https://msdn.microsoft.com/en-us/library/windows/desktop/aa363362(v=vs.85).aspx][MSDN - OutputDebugString]]

*** Entry point
The linker, by default, expects a certain function call, which indicates the start of the
program. If the default function is not present in the program, the linker won be able to link
the entry point of the program with Windows. It's not recommended to change the default entry
point in the linker configuration, but it's possible.

The ~WinMain~ is the default function, called by Windows as entry point to execute the program.
The header ~windows.h~ needs to be included when using windows specific keywords like ~HINSTANCE~ and
~OutputDebugStringA~.

The requirements to properly call ~WinMain~ can be found in the official [[https://msdn.microsoft.com/en-us/library/windows/desktop/ms633559(v=vs.85).aspx][MSDN - WinMain]] docs.

#+NAME: win32_handmade.cpp
#+BEGIN_SRC c
  #include <windows.h>

  int CALLBACK WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow)
  {
    OutputDebugStringA("Some function\n");
    return 0;
  };
#+END_SRC

*** Functions
A /forward function declaration/ notifies the compiler that it's legal to call a function *without* the
function definition. Nevertheless the build might fail, when the implementation of the function
could not be found during the linking process.

The /function definition/ is the implementation of the declared function.

During the *compilation* phase the compilers marks the unresolved function definitions. During the
*linking* phase, the linker will try to find the correct function defintions.

** Day 2
*** Resources
- [[https://wordsandbuttons.online/you_dont_have_to_learn_assembly_to_read_disassembly.html][Reading disassembly]]

*** ASCII vs Unicode
Microsoft had to support Unicode at some point, since ASCII can handle foreign languages. They used
macros to either use the unicode or ascii implementation, depending on the environment of the
program.

You can by bypass the compiler by using ~OutputDebugStringA~ instead of the more general
~OutputDebugString~.

*** Disassembly
/Does the compiler do what we expect it to do?/
It's essential to rudimentary read assembly code. You learn to debug problems on a lower level and
understand exactly what the processor is doing, when executing the code.

1. Set a breakpoint
2. Start in debug mode
3. Right-click > Go To Disassembly

#+BEGIN_SRC asm
    ;Test = 255;
  00031718  mov         byte ptr [Test],0FFh
    ;Test = Test + 1;
  0003171C  movzx       eax,byte ptr [Test]
  00031720  add         eax,1
  00031723  mov         byte ptr [Test],al
#+END_SRC

Putting a value inside a location (variable) does *not* require the processor to do any calculations.
Adding a certain number to an existing variable requires the processor to move it closer to the
processor's /registers/ to operate on them.

*** Registers
The ~EAX~ register happens to be 32-bit wide, which is far bigger than a byte (used for a ~char~). The
lowest two bits of the ~EAX~ can be pulled out via ~al~. That value is ultimately the value, which is
going to be sent back into the location of the variable (Test).

** Day 3
*** Memory (hardware)
The processor reading/writing from memory is a non-trivial problem. Accessing memory is slow,
because of the laws of physics. Imagine a processor with a clock speed of 3,2 GHz, the speed of
light is \pm 300 000 m/s. The distance a photon is able to travel per second is not far!
\begin{equation}
d = \dfrac{ \pm 300000 m/s}{3,2Ghz}
d = \pm 9 cm
\end{equation}

Usually the memory is about 9-10 cm away from the CPU. That implies a photon is not able to go the
memory and back within 1 CPU cycle. The only way to reduce the /latency/ is to shorten the distance
between the CPU and memory. CPU's nowadays have an in-chip memory cache (very small), which makes
access to memory insanely fast (if it was stored in those caches).

/Bandwidth/ is a bit easier to improve, since it's bottlenecked by the components and their capability
of sending as much stuff down the wires per second.

*** Pointers
The ~*~ (star) in front of a variable notifies the compiler to free some memory to store the memory
location of another variable. The size of that /address/ is the same size as an ~int~.
The ~&~ (ampersand) in front of a variable is the /address operator/, which gives back the address of a
variable stored in memory.

The address location is the location of the variable in the virtual memory, *not* the actual physical
memory (only for modern day systems). The /virtual memory/ is a way to stop different programs
accessing and modifying the same piece of memory.

The CPU has a table which secretly maps the virtual memory of a certain program to the actual place
in physical memory.

*** Stack
is a piece of memory which is managed by the compiler/OS. Everytime a function gets invoked a new
stack is created with an own little environment with variables, etc.

You can actually see a new stack being created closeby a local variable of the previous stack, via
*Debug > Memory > Memory 1*. A variable created in the new function call, should be relatively close
in memory to the local variable of the parent function.

** Day 4
*** Endianness
It's up to the CPU how to interpret/read values which span multiple bytes (such as ~short~, which is
represented by two bytes). The CPU knows how to add two bytes, to get the representation of a 16
bits, but there is no hard law on how to store it.
- little endian :: lowest byte of a value representation first (x86, arm, x64)
- big endian :: highest byte first (powerpc)

Important to remember the legacy, since some of the software today (like for example the ~.psd~ file
format is using /big endian/). It's not possible to load big endian data onto a little endian machine,
unless it passes through some conversion first.
The modern devices are using /little endian/ so it's generally not something to worry about too much.

*** ~struct~'s
declare a layout in memory, which holds a multitude of basic types as fields, which allows access to
it's member via the name of the struct.

The compiler is not constraint to lay each of the fields as compact as possible. A ~char~ might be
respresented by 4 bytes if the processor if it's optimized to access values on 4 bytes boundaries
(as it might be slower to access a single byte).

*** Casting
Be cautious. Casting values to a *higher* memory size results in garbage values being included.
Casting values to a *lower* memory size will chop the value, if the value is too big to be represented
by the low memory size.

** Day 5
*** How does code turn into an executable?
Code goes through a /compiler/, which spits out ~obj~ files. Together with ~lib~ files (obj files compared
together to form a group), such as system files, goes through the /linker/, which spits out a
Windows/Intel executable.

Microsoft defined the layout on disk for the executable file. The /header/ defines the properties of
the file (such as it being an ~.exe~), the /fixup table/ keeps all the references from where our program
calls into Windows and the /CPU specific code/ are all the instructions for the CPU.

*** How does Windows roughly run an executable?
Windows loads up the AMD/Intel specific instructions and put into the memory of the machine. The
missing code where Windows is supposed to patch the memory location with it's own code is found in
the fixup table. However, Windows doesn't actually reference to it's "real" memory where the Windows
code is held in memory. The memory address is obfuscated by Windows, since your program can only
call into it's own /Virtual Memory Address/ assigned by Windows.

* Day 001 - Setting up the Windows Build
** How does Windows calls our code?
It doesn't!
Windows kernels calls the CRT (C Runtime), which calls the ~WinMain~ function of our code.

** Windows dependencies
Windows needs to bind to our code, find the places where we call Windows functions and patch those
with pointers to the location in memory where those functions are running at that time.

The functions coming from the /kernel/ don't require an /import library/, since Windows snuck the import
already for us. ~WinMain~ is part of those kernel functions. All other calls, such as the UI system,
require you to build the code with those specific ~.dll~'s.

Trying to compile code without these imports results in the /linker/ complaining about code that's
supposed to be available, but it couldn't find the information how to insert a particular call to
Windows when patching the code.

Read the MSDN pages for the functions to know which libraries need to be included!

** Automation with ~.bat~ files
It's a simplified version of more commonly known /make/ systems, such as ~gnu make~, ~ninja~ or ~cmake~. The
more complex the build tools are, the more time gets invested in them. The /batch/ file will be
responsible for setting the environment and compiling all the code all the time.
According to Casey there is no need for compiling the modified files only to speed up the build
process if you program sanely.

*** Setting the ~env~
The ~cl~ command-line tool, which controls the Microsoft C/C++ compilers and linker, comes
pre-installed with Visual Studio 2019 (*check* the /C++ Desktop Environment/). However it's not a
command which is exposed by default to the command prompt (sad).

#+NAME: setenv.bat
#+BEGIN_SRC bat
  @echo off

  call "C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build\vcvarsall.bat" x64
  REM set path=D:\Office\Documents\dev\handmade\misc;%path%
#+END_SRC

*** Building
using a single batch file (apparantly controversial), since the project will be compiled every
single time. Alternative build tools: /make/, /ninja/, /cmake/, ... which offer more advanced features
(such as partly compiling code to improve dev speed).

#+NAME: build.bat
#+BEGIN_SRC bat
  @echo off

  mkdir ..\build
  pushd ..\build
  cl -Zi ..\code\win32_handmade.cpp user32.lib
  popd
#+END_SRC

** Debugging ~devenv~ (starts up Visual Studio)
Don't forget to change the working directory of the ~win32_handmade~ start-up project to use the root
of project, rather than the build folder.

* Day 002 - Opening a Win32 Window
- [[https://docs.microsoft.com/en-us/windows/win32/learnwin32/creating-a-window][Creating a Window]]
- [[https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-tagwndclassa][WNDCLASSA]]
- [[https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms633573(v%253Dvs.85)][WindowProc callback function]]
- [[https://docs.microsoft.com/en-us/previous-versions/aa932511(v%253dmsdn.10)][RegisterClass]]
- [[https://docs.microsoft.com/en-us/previous-versions/aa921213(v%253dmsdn.10)][GetMessage]]
- [[https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-beginpaint][BeginPaint]]
- [[https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-patblt][PatBlt]]

** Initializing ~WNDCLASS~
Two possibilities:
- zero is initialization :: clear the whole struct to zero (used when performance is not a concern)
- contructors :: initializes values in the typical C++ way

* Day 003 - Allocating a Backbuffer
- [[https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-postquitmessage][PostQuitMessage]]
- [[https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getclientrect][GetClientRect]]
- [[https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createdibsection][CreateDIBSection]]
- [[https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-stretchdibits][StretchDIBits]]

** Different use cases for ~static~
The ~static~ keyword has different meanings depending on the context it's being used. It can either
1. Scope a function to a file (making it invisible for other files to import it)
2. Define it locally in a function to persist a value when the scope is recreated
3. Define it globally for everyone to be used

Therefore it's a good practice to define better keywords for these different meanings.
1. ~#define internal static~
2. ~#define local_persist static~
2. ~#define global_variable static~
